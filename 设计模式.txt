设计模式

单例设计模式：
    1.所谓类的单例设计模式，就是采用一定的方法保证在整个的软件系统中，对某个类只能存在一个对象实例
    2.如何实现p323
    3.区分饿汉式和懒汉式：
        饿汉式：
            好处：线程安全的
            坏处：对象加载时间长（因为一开始就加载了）
        懒汉式：
            好处：延迟对象的创建
            坏处：线程不安全（按照p323的写法，在getInstance时多个线程可能会new多个对象）
    4.应用场景：
        网站计数器，一般是单例模式实现，否则难以同步
        应用程序的日志应用，一般为单例模式实现，这一般是由于共享的日志文件一直处于打开状态，只能由一个实例去操作
        数据库连接池的设计一般采用单例模式，因为数据库连接是一种数据库资源
        项目中，读取配置文件的类，一般也只有一个对象，没必要每次使用配置文件数据都生成一个对象去读取
        Application是单例的典型应用
        Windows的任务管理器是很典型的单例模式
        Windows的回收站也是典型的单例应用，在整个系统运行过程中，回收站一直维护着仅有的一个实例





代理模式
    代理模式是Java开发中使用较多的一种设计模式。代理设计就是为其他对象提供一种代理以控制
    明星  被代理类   经纪人  代理类  明星要做的一些事通过经纪人帮他做
    应用场景：
        安全代理：屏蔽对真实角色的直接访问
        远程代理：通过代理类处理远程方法调用
        延迟加载：先加载轻量级的代理对象，真正需要再加载真实对象
            比如要开发一个大文档查看软件，大文档中有大的图片，有可能一个图片100mb，在打开文件时，不可能将所有的
            图片都显示出来，这样就可以使用代理模式，当需要查看图片时，用proxy来进行大图片的打开

        分类：
            静态代理(静态定义代理类)
            动态代理(动态生成代理类)
                JDK自带的动态代理，需要反射等知识


工厂模式  不希望建造者（new对象的）和调用者（用对象做事的）绑在一起
    工厂是用来造对象的
    工厂模式：实现了创建者与调用者的分离。即将创建对象的具体过程屏蔽隔离起来，达到提高灵活性的目的
        其实设计模式和面向对象设计原则都是为了使得开发项目更加容易扩展和维护，解决方式就是一个"分工"
    社会的发展也是这样，分工越来越细


面向对象的设计原则
(总共六个)：这里说几个和工厂模式相关的
    OCP(开闭原则)
        一个软件的实体应当对扩展开放，对修改关闭
        我们写完的代码，不能因为有需求变化就去修改代码。我们可以通过新增代码的方式去解决变化的需求。如果
        每次需求变动都去修改原有的代码，那么原有的代码就存在被改错的风险，当然这其中存在有意无意的修改，
        都会导致原有正常运行的功能失效的风险，这样很有可能会展开可怕的蝴蝶效应，是维护工作剧增
        说到底，开闭原则除了表面上的可扩展性强以外，在企业中更看重的是维护成本
    DIP(依赖倒转原则)
        要针对接口编程，不要针对实现编程
        如果A中关联B，那么尽量使得B实现某个接口，然后A与接口发生关系，不与B实现类发生关系
        依赖倒转的潜台词是：面向抽象编程，解耦调用者和被调用者

    LOD(迪米特法则)
        只与你直接的朋友通信，而避免和陌生人通信
        要求尽量地封装，尽量地独立，尽量地使用低级别的访问修饰符。这是封装特性的典型体现。
        一个类如果暴露太多私用的方法和字段，会让调用者很茫然。并且会给类造成不必要的判断代码。
        所以我们尽量使用低的访问修饰符，让外界不知道我们的内部。这也是面向对象的基本思路。这是
        迪米特原则的一个特性，无法了解类的更多私有信息
        另外，迪米特原则要求类之间的直接联系尽量的少，两个类的交互，通过第三个中介类来实现
        迪米特原则的潜台词是：不和陌生人说话，有事找中介代理

工厂模式分类
    简单工厂模式：
        用来生产同一等级结构中的任意产品。(对于增加新的产品，需要修改已有代码)
        调用者只知道他要什么，从哪里拿，如何创建，不需要知道分工。多出了一个专门
        生产Car的实现类对象的工厂类。把调用者和创建者分类。
        简单工厂模式也称静态工厂模式，就是工厂类一般使用静态方法，通过接收的参数的不同
        来返回不同的实例对象。
        缺点：对于增加新产品，不修改代码的话是无法扩展的。违反了开闭原则(对扩展开放，对修改封闭)

    工厂方法模式：
        用来生产同一等级结构中的固定产品。(支持增加任意产品)
        简单工厂模式和工厂方法模式并没有真正避免代码的改动。在简单工厂模式中，新产品的加入要修改
        工厂角色中的判断语句；在工厂方法模式中，要么将判断逻辑留在抽象工厂角色中，要么在客户程序
        中将具体工厂角色写死.而且产品对象创建条件的改变必然会引起工厂角色的修改。面对这种情况，
        Java的反射机制与配置文件巧妙地结合突破了限制，这在Spring中完美地体现了出来

    工厂方法和简单工厂可以合在一起看作一个广义上的工厂方法模式(简单工厂是工厂方法的一种特例)

    抽象工厂模式：
        用来生产不同产品族的全部产品(对于增加新的产品，无能为力；支持增加产品族)
        抽象工厂模式是三个里面最为抽象、最具一般性的
        抽象工厂模式的用意为：给客户端提供一个接口，可以创建多个产品族的产品对象
        而且使用抽象工厂模式还要满足以下条件：
            1.系统中有多个产品族，而系统一次只可能消费其中一族产品
            2.属于同一个产品族的产品一起使用
        暂略
p354