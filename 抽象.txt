抽象类
随着继承层次中一个个新子类的定义，类变得越来越具体，而父类则越来越一般，更加通用。
类的设计应该保证父类和子类能够共享特征。有时将一个父类设计得非常抽象，以至于它没有具体的实例
这样的类叫做抽象类
    比如说一个学校管理系统中，学生类、教师类等都继承于<人>类，但人这个类并不需要有实例

加了abstract后，这个类就不能在new对象了，就是不能在创建该抽象类的实例了
抽象类 p341


abstract可以用来修饰的结构：类、方法

abstract修饰类：抽象类
        >此类不能够实例化，构造器只能给子类用了
        >抽象类中一定有构造器，但是给子类用的，便于子类实例化时调用。对抽象类自己没用（不能new）

abstract修饰方法：抽象方法
        >抽象方法只有方法的声明，没有方法体
        >包含抽象方法的类一定是抽象类,非抽象类不能声明抽象方法，抽象方法只能在抽象类中
        >抽象类中可以没有抽象方法，可以有非抽象方法
        >子类继承了抽象类后必须要重写抽象方法或该子类也声明为抽象类
            因为继承了之后它里面就有抽象方法了，而只有抽象类里才能有抽象方法，除非重写
        >若子类重写了父类中的所有抽象方法后，此子类方可实例化
            若子类没有重写父类中的所有抽象方法，则此子类只能为抽象类，需要用abstract进行修饰

abstract使用注意点：
    1.abstract不能用来修饰：属性、构造器等结构
    2.abstract不能用来修饰：私有private方法(私有方法不能被重写，子类继承了但没法重写)
                          静态方法(static的方法没有重写这种说法)
                          final方法(final方法不能被重写)
                          final类(final类不能被继承)



创建抽象类的匿名子类对象p345
                    //创建了一个匿名子类的对象：p
                    Person p = new Person() {
                        @Override
                        void eat() {
                            System.out.println("吃le饭");
                        }
                    };//匿名类，new的是抽象类的匿名子类



模板方法设计模式(TemplateMethod)
抽象类体现的是一种模板模式的设计，抽象类作为多个子类的通用模板，子类在抽象类的基础上进行扩展、改造，
但子类总体上会保留抽象类的行为方式

解决的问题：
    当功能内部一部分实现是确定的，一部分实现是不确定的。这时可以把不确定的部分暴露出去，让子类去实现
    换句话说，在软件开发中实现了一个算法时，整体步骤很固定、通用，这些步骤已经在父类中写好了。但是某些
    部分易变，易变部分可以抽象出来，供不同子类实现。这就是模板模式
    p346
模板方法的应用
    模板方法设计模式是编程中经常用得到的模式。各个框架、类库都有它的影子，比如常见的有：
            数据库访问的封装
            Junit单元测试
            JavaWeb的Servlet中关于doGet/doPost方法调用
            Hibernate中模板程序
            Spring中JDBCTemlate、HibernateTemplate等